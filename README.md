# Architecture

- [Removing User Interface Complexity, or Why React is Awesome](http://jlongster.com/Removing-User-Interface-Complexity,-or-Why-React-is-Awesome)

  > I ask that you set aside your framework prejudices and read this post with an open mind. This post is not to evangelize React specifically, but to explain why its technique is profound. I want developers steeped in other technologies to take a hard look at these techniques, particularly those involved in Web Components.

# Learning

- [How Developers Stop Learning: Rise of the Expert Beginner](http://www.daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner)

  > On the other hand, the least talented developers are more likely to stay put since they’ll have a hard time convincing other companies to hire them. This serves as important perspective for understanding why it’s common to find people with titles like “super-duper-senior-principal-fellow-architect-awesome-dude,” who make a lot of money and perhaps even wield a lot of authority but aren’t very good at what they do.
  
  > There’s nothing you can do to improve as long as you keep bowling like that. You’ve maxed out. If you want to get better, you’re going to have to learn to bowl properly. You need a different ball, a different style of throwing it, and you need to put your fingers in it like a big boy. And the worst part is that you’re going to get way worse before you get better, and it will be a good bit of time before you get back to and surpass your current average.
  
- [Why debugging is all about understanding](http://futurice.com/blog/why-debugging-is-all-about-understanding)
  
  > Programmers often make the bug "the enemy", and it's not rare to swear at the computer. Programming, however, is a lot about understanding correctly, not about typing and building. Most of our programming time is spent understanding how all parts should be connected, and only a small fraction of our time is spent with actual keyboard typing.

# Process

- [Code Review Checklist](https://ana-balica.github.io/2017/02/21/code-review-checklist/)

  > Over the last couple of months, I’ve developed my own internal code review checklist. I use it both for reviewing for own finished code and my teammates code complete tickets. It’s split up into 3 sections: code, automated testing and manual testing.

# Programming

- [The Cost of Abstraction](http://sam-koblenski.blogspot.de/2014/07/the-cost-of-abstraction.html)

  > Adding abstractions only when and where they're necessary allows a software system to evolve naturally, becoming the solution it needs to be without adding a lot of extra cruft. If the team accepts this process and allows it to happen instead of fighting against it, development will have a pleasant flow to it. Progress will be faster and require less effort when the system isn't overloaded with unnecessary, costly abstractions.
  
- [Write code that is easy to delete, not easy to extend.](http://programmingisterrible.com/post/139222674273/write-code-that-is-easy-to-delete-not-easy-to)

  > You don’t need to throw it all away but you will need to delete some of it. Good code isn’t about getting it right the first time. Good code is just legacy code that doesn’t get in the way.
  >
  > Good code is easy to delete.

- [Call me Maybe](https://glebbahmutov.com/blog/call-me-maybe/)

  > Replacing the built-in OR and TERNARY operators with Maybe monads.

- [The Return of Stream I/O](https://www.youtube.com/watch?v=Tkjg179M-Nc)

  > While the I/O Monad has been established as the standard in Haskell, we are seeing the resurgence of variations of Stream I/O in Frontend, through tools like Cycle.js and Elm. In this talk we will explore the benefits and downsides of Stream I/O, and what it promises for the future.

- [WTF is JSX](https://jasonformat.com/wtf-is-jsx/)

  > JSX is actually quite straightforward: take 1 minute and read this, and you'll understand everything there is to know about this interesting alternative to templates.
  
# Quotes

> The primary cost of abstaction is indirection. In my experience, you should only abstract when the added abstraction clarifies things more than the added indirection confuses them. - Bryan Edds 
